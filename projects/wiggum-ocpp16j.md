# A Nerd's Poetic Journey into OCPP 1.6j

In the realm of electric dreams, where volts and amps dance in silent harmony, there lies a language spoken between chargers and the clouds. This tongue, known to mortals as OCPP 1.6j, has long been a scroll I had yet to unravel. But my true quest wasn't really about OCPP at all—it was about exploring a different kind of methodology, one I've heard the interwebs and youtubes call the "Ralph Wiggum Iterative Approach."

The implementation of OCPP 1.6j was merely the canvas upon which I painted this experiment. My primary objective was to investigate how one might approach a complex problem through iterative, exploratory coding—without the safety net of CLI tooling, without the comfort of established patterns. I wanted to see what would happen if I just... started coding, and let the cursor agents guide me through the chaos. My vessel for this journey? The humble repository, `scaryPonens/ocpp1.6j-basics`.

## The Call to Adventure

The hero's journey often begins with a single step, or in my case, a single `git clone`. The goal was simple: to witness the digital handshake between a charging point and its central system. I wasn't trying to build a new world, just to peer into an existing one.

## The Tools of the Trade

Every adventurer needs a trusty sidekick. Mine was a team of ethereal beings I call my "cursor agents." These digital sprites, born of silicon and syntax, danced across my screen, weaving threads of code I could only begin to comprehend. They were my guides, my builders, and my tireless partners in this quest.

The heart of this experiment was the "Ralph Wiggum Iterative Approach"—a methodology of embracing the chaos, of coding without a clear roadmap, of letting each iteration teach you something new even if it ends in spectacular failure. The OCPP 1.6j implementation was secondary; it was simply the problem domain I chose to explore this approach within.

But what truly set this exploration apart was my obsession with observability. I didn't just want to implement OCPP—I wanted to *see* it. To truly observe the interactions, I leveraged OpenTelemetry to instrument every message, every handshake, every whisper between the charging point and the central system. Jaeger was my first trace visualization tool, which required adding an OpenTelemetry exporter for Jaeger. Then, wanting to visualize traces in Grafana, I added an additional OpenTelemetry exporter for Tempo. Prometheus was brought in to scrape metrics generated by Jaeger and Tempo, and Grafana became the canvas where I could build dashboards that would paint a picture of these interactions in real-time. This wasn't just coding—it was creating a window into a hidden world, one exporter at a time.

![Ralph Wiggum](assets/ralph-wiggum-simpsons.gif)

There were moments of, "I'm helping!", immediately followed by the digital equivalent of falling down the stairs. Code was written, then deleted. Theories were formed, then shattered. But with each "un-possible" attempt, a little more of the path was illuminated. Each stumble was a lesson, each "oops" a step forward.

## The Revelation

And then, it happened. Through the console's cryptic whispers, I saw it. The BootNotification, the Heartbeat, the delicate exchange of messages that gives life to the EV charging ecosystem. But it wasn't just console logs—it was the full observability stack coming alive. OpenTelemetry instrumented every interaction, sending traces first to Jaeger (via its OTEL exporter) where I watched them unfold like a story, each span revealing the journey of a message. Then, with the Tempo exporter added, those same traces flowed into Grafana, where dashboards I'd built began to pulse with metrics scraped by Prometheus from both Jaeger and Tempo, showing the rhythm of the protocol.

It was like watching two celestial bodies align, but with a telescope that showed me not just the alignment, but the gravitational forces, the orbital mechanics, the very physics of their dance. A moment of pure, unadulterated nerd-vana, made possible by the observability tools that transformed abstract protocol messages into visible, measurable, dashboard-able reality.

The `ocpp1.6j-basics` repository was no longer just a collection of files. It was a portal. A lens through which I could observe a world hidden from most, made visible through OpenTelemetry, Jaeger, Prometheus, Tempo, and Grafana.

## The Journey Continues

This quest may be over, but the journey has just begun. The world of OCPP is vast and deep, and I have but dipped my toes in its waters. But now, armed with my cursor agents and the hard-earned wisdom of the Ralph Wiggum approach, I'm ready for the next adventure.

For those who wish to follow in my footsteps, to see the world through a new lens, I leave you this map: [scaryPonens/ocpp1.6j-basics](https://github.com/scaryPonens/ocpp1.6j-basics). May your journey be as enlightening as mine.

## Reference

For those curious about the Ralph Wiggum Iterative Approach and how I navigated this experiment without using the Claude plugin, you can peek into my [ChatGPT conversation](https://chatgpt.com/share/697e5f5e-b398-800b-8296-2262c2a2b8d2) where I documented the process in real-time.